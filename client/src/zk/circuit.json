{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"15815086738016159491","abi":{"parameters":[{"name":"candidates","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"pick_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"user_seed","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"nZjNbhs5EITfRWcfyO7m377KYhE4jhIIEGRDsRdYBHn3Hc7UN04OMgJd1GVJLHcXWewe/Th8OX5++/bpdPn6/P3w198/Dp+vp/P59O3T+fnp8fX0fFne/fHz4cCfn16vx+Py1uGXz5dVL4/X4+X18Nfl7Xx+OPz7eH5bv/T95fGyxtfH6/JpejgcL1+WuBB+PZ2PE/18eF+dbi+1Flpsve/Lyx+v95y13q3csb6mrvU14tZ6/+D/N4oPf19vv6+Pj+pPuwAtt1sM5TZDzr2KIVsad+UQac+h3KyifZBDG40ceq63GPpthlFdBKPdsz6nvYac+rinhuGkkEfczOGjs7TXUJvfcxarsb7HHetb4f+3etf6jhfaGPes373c+j1e7Glofbd0a/1H59j67iUbcdcOvu/APbfReLdB+sUGf06wHOP9EKYSdzF43hnidxn/Wf56fDpdf2sCB1u++XDw9TXW17K+1kW5h0NbX/v6mvMkXaIpumIozoXze1WxKXbFsUVLilnRFF0xFMVnk2/RxZpiVxxb9Mm3bL1nRVN0xcm3XKE++ZYd8qrYtrxd+bnyC+UXyi+UXyi/UH6h/EL1huoN8YXyK0kxK5qiK4bi5Fs8UOqWd2mKXXFssaremre66uRbmkD1ra6q/ajKryq/qvyq8quqt6nepnqb6m2qt6neJr6m/Wjaj6b9aKq3q96uerttdXXtRw/Foqh6u+rtqrePrb6RtvpG3uobOn9D+Q3lN5TfUL1D9Q7VO1RvTgmQAQZwgDZl8SGgAhqgA1R5zmkrNWedxZwN4IAAFEAFtK3ivFqmTjC2mvNqmtV85IxtMr7JGCfjnGxY0fCiYUZDDUcNh9l1QLM7ADUcNRw1HDVWG83aXec0RwKgRqBGoEagxuqmWftqp1n76qdZ+2qo9aIh50LOhZwLahTUKKhRUKOgRkGNghoF5qrDm2sGoEZFjYoaFTVWi83aq85wrh2AGg01Gmo01FidNmtfrTZrb7qr8mq2WXsj50bOjZw7anTU6KjRUaOjRkeNjhp9v6c5z53zPFBjoMZAjYEaq/1m7YPzPDjPAzUGagypYSkBdItZ0jVmSfeYJV1klugEqQIaoAPoLnlvL/SXTIPJdJhMi6FnWabJZLpMps1kqWGWABmgq81M59ksAAVQAQ3QAbrhzHXFmeuOM9clZ07OTs5Ozo4ajhq0MqOXGc3M6GZGO7PY+63Os0UBoEagRsjdFuxgYQdLBhgANQpqFLnbitxtRe62IncbHrRKzpWcKzlXcq6oUfcpATXoc0ajMzqdNXawsYPNAA5AjYYaTe62xg42drChRkeNjhodNbrcbV3uti53W5e7DQ9aJ+dOzgM1BmoM1KADGi3Q6IFGEzS6oI19bNrnpgTIAAM4QO72pPPsqQIaoAOkhud9JJO7PcvdnuVuZ2x0POgMjs7k6IyOzuzoDI9OH3T6oNMHnT7o9EFnhHRmSGeI9H2KdNRw1HC52/dJ0gOAGo4ajhqOGi53e8jdHnK3h9zteNAZKp2p0hkrnbnSGSydPuj0QacPOn3Q6YPOeOmlAFCjoEaRu50Z0xkyvTJVV8bqihoVNarc7VXu9ip3e5W7HQ8646YzbzoDpzNxOiOnM3N6Qw36oNMHnT7oDJ7O5Omd89w5zx01Omp0uduZP50B1DtqDNQYqDFQY8jdPuRuHzxnDLnb8aCP/VFjf9bgYYNZNJhFg1k0Eg8c9MGgDwZ9MJhFg1k0cgJkgM5zMIsGs2gwiwazaOQG6ACd5zCd5zCd55getDSBAwJQAPOJcj5kTg9u73TAEJge3EDWlx1mh9lhdpgdZofZYXaYA+aAOWAOmAPmgDlgDpgD5oC5wFxgLjAXmAvMBeYCc4G5wFxgrjDXlfnnfOy/nh4/n4/ft59vv75dnn75Nff1vxc+4ffel+vz0/HL2/U4H/rXz5afAf4H","file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"50":{"source":"global N: u32 = 16;\nglobal M: u32 = 8;\n\nuse dep::std::hash::poseidon2::Poseidon2;\n\nfn main(\n    candidates: [Field; N],\n    pick_count: pub u32,\n    user_seed: pub Field\n) -> pub [Field; M] {\n    // Clamp pick_count to [1, M] and no more than N\n    let effective_count = if pick_count > M { M }\n        else if pick_count < 1 { 1 }\n        else { pick_count };\n\n    // Fisher-Yates shuffle using Poseidon2 as deterministic RNG\n    let mut shuffled = candidates;\n    let mut seed = user_seed;\n\n    for i in 0..N {\n        // Deterministic hash for randomness: each step's output is new seed\n        let rnd = Poseidon2::hash([seed, i.into()], 1);\n        let j = (rnd as u32) % (N - i) + i;\n        // Swap shuffled[i] <-> shuffled[j]\n        let temp = shuffled[i];\n        shuffled[i] = shuffled[j];\n        shuffled[j] = temp;\n        seed = rnd;\n    }\n\n    // Pick the first 'effective_count' elements, pad with 0 up to M\n    let mut result: [Field; M] = [0; M];\n    for k in 0..M {\n        if k < effective_count {\n            result[k] = shuffled[k];\n        } else {\n            result[k] = 0;\n        }\n    }\n    result\n}\n\n#[test]\nfn test_random_picker() {\n    let cands: [Field; 16] = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16];\n    let pick: u32 = 3;\n    let seed: Field = 42;\n    let result: [Field; 8] = main(cands, pick, seed);\n    std::println(result);   \n    std::println(result[0]);\n}\n","path":"/Users/yongho/Desktop/zk_random_number_generator/circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}